# Liquid Error Handling and Edge Cases
# Progressive difficulty: 200-350
# Focus: Error modes (lax/strict), division by zero, invalid filters, unknown tags, malformed syntax

- name: "division_by_zero_lax"
  template: "{{ 10 | divided_by: 0 }}"
  expected: "Liquid error (line 1): divided by 0"
  complexity: 200
  error_mode: lax
  render_errors: true
  hint: |
    In lax mode, division by zero returns an error message rather than crashing.
    The divided_by filter must detect when divisor is 0 and handle it gracefully.
    Liquid displays an informative error message while continuing to render,
    which helps with debugging while preventing template crashes in production.

- name: "division_by_zero_with_float_lax"
  template: "{{ 10.0 | divided_by: 0.0 }}"
  expected: "Infinity"
  complexity: 210
  error_mode: lax
  hint: |
    Float division by zero in Liquid returns "Infinity" following standard
    floating-point arithmetic behavior. This differs from integer division by zero
    which returns an error message. The implementation respects IEEE 754 floating-point
    standards where dividing by 0.0 produces infinity rather than an error.

- name: "modulo_by_zero_lax"
  template: "{{ 10 | modulo: 0 }}"
  expected: "Liquid error (line 1): divided by 0"
  complexity: 215
  error_mode: lax
  render_errors: true
  hint: |
    The modulo filter handles division by zero the same as divided_by.
    In lax mode, Liquid returns an error message when attempting to calculate
    remainder with zero divisor. This provides helpful debugging information
    while preventing template crashes.

- name: "undefined_variable_lax"
  template: "{{ missing_var }}"
  environment: {}
  expected: ""
  complexity: 205
  error_mode: lax
  hint: |
    In lax mode, undefined variables render as empty strings (nil output).
    The variable lookup system should return nil for variables not found
    in the context. This is fundamental to Liquid's forgiving error handling.
    Do not throw errors or warnings for missing variables in lax mode.

- name: "undefined_variable_strict_in_liquid_ruby"
  template: "{{ missing_var }}"
  environment: {}
  expected: ""
  complexity: 230
  error_mode: strict
  hint: |
    In liquid-ruby, strict mode only affects parsing, not runtime variable
    lookup. Undefined variables still render as empty strings. Other
    implementations may raise errors for undefined variables in strict mode.

- name: "property_access_on_nil_lax"
  template: "{{ missing.property }}"
  environment: {}
  expected: ""
  complexity: 220
  error_mode: lax
  hint: |
    Accessing properties on nil/undefined values should fail gracefully in lax mode.
    When 'missing' resolves to nil, .property access should also return nil
    (empty string output). This is nil-safe navigation - each property access
    checks if the base is nil before attempting to access. Prevents null
    pointer exceptions in templates.

- name: "property_access_on_nil_strict_in_liquid_ruby"
  template: "{{ missing.property }}"
  environment: {}
  expected: ""
  complexity: 245
  error_mode: strict
  hint: |
    In liquid-ruby, strict mode only affects parsing. Property access on
    undefined variables still returns nil (empty output). Other implementations
    may raise errors for property access on undefined variables in strict mode.

- name: "property_access_on_non_object_lax"
  template: "{{ number.property }}"
  environment: { number: 42 }
  expected: ""
  complexity: 235
  error_mode: lax
  hint: |
    Attempting to access properties on primitive types (numbers, strings)
    should return nil in lax mode. The number 42 doesn't have a 'property'
    attribute, so gracefully return nil. Some implementations may have
    special handling for string methods (like .size), but unknown properties
    should always return nil on primitives.

- name: "array_access_on_non_array_lax"
  template: "{{ string[0] }}"
  environment: { string: "hello" }
  expected: ""
  complexity: 240
  error_mode: lax
  hint: |
    Bracket notation on non-indexable types should return nil in lax mode.
    While strings might support indexing in some implementations, attempting
    to index a string as an array should fail gracefully. Only proper arrays
    and hashes should support bracket notation. Return nil for incompatible
    type access.

- name: "unknown_filter_lax"
  template: "{{ 'hello' | nonexistent_filter }}"
  expected: "hello"
  complexity: 250
  error_mode: lax
  hint: |
    In lax mode, unknown filters should be silently ignored, passing through
    the input value unchanged. This allows templates to degrade gracefully
    when filters are removed or unavailable. The filter chain continues with
    the original value as if the unknown filter wasn't there. This is critical
    for backward compatibility.

- name: "unknown_filter_strict_in_liquid_ruby"
  template: "{{ 'hello' | nonexistent_filter }}"
  expected: "hello"
  complexity: 270
  error_mode: strict
  hint: |
    In liquid-ruby, unknown filters are ignored even in strict mode.
    The filter passes through its input unchanged, like lax mode.
    Other implementations may raise errors for unknown filters in strict mode.

- name: "filter_with_invalid_argument_lax"
  template: "{{ 'hello' | slice: 'not a number' }}"
  expected: "Liquid error (line 1): invalid integer"
  complexity: 255
  error_mode: lax
  render_errors: true
  hint: |
    Filters that expect numeric arguments but receive invalid input return
    error messages in Liquid's lax mode. The slice filter expects an integer
    index but gets a string. Rather than silently failing, Liquid provides
    a helpful error message indicating the type mismatch while continuing
    template execution.

- name: "chained_filter_error_propagation_lax"
  template: "{{ 'test' | nonexistent | upcase }}"
  expected: "TEST"
  complexity: 265
  error_mode: lax
  hint: |
    When an unknown filter appears in a chain in lax mode, it passes through
    its input unchanged, and the chain continues. Here 'nonexistent' passes
    'test' through unchanged, then upcase converts it to 'TEST'. Error
    propagation in filter chains should not break subsequent filters in
    lax mode. Each filter processes what it receives.

- name: "unknown_tag_lax"
  template: "{% nonexistent_tag %}content{% endnonexistent_tag %}"
  complexity: 280
  error_mode: lax
  errors:
    parse_error:
      - "Unknown tag"
  hint: |
    In Liquid, unknown tags cause a parse error even in lax mode, rather than
    being rendered as raw text. The parser detects unknown tags and raises a
    SyntaxError with "Unknown tag 'nonexistent_tag'". This provides immediate
    feedback about invalid template syntax rather than silently outputting
    the tag syntax as text.

- name: "unknown_tag_strict_parse_error"
  template: "{% nonexistent_tag %}content{% endnonexistent_tag %}"
  complexity: 300
  error_mode: strict
  errors:
    parse_error:
      - "Unknown tag"
  hint: |
    In liquid-ruby strict mode, unknown tags cause a parse error rather than
    a render error. The template fails to parse with "Unknown tag 'nonexistent_tag'".
    This is stricter than lax mode which outputs tags as raw text.

- name: "malformed_syntax_unclosed_tag_lax"
  template: "{% if true %}hello"
  complexity: 320
  error_mode: lax
  errors:
    parse_error:
      - "'if' tag was never closed"
  hint: |
    Syntax errors should always raise errors even in lax mode, because the
    template cannot be parsed correctly. An unclosed 'if' tag makes the
    template structure ambiguous. The parser should detect when block tags
    (if, for, case, etc.) are not properly closed before end-of-template.

- name: "malformed_syntax_invalid_filter_separator"
  template: "{{ 'hello' || upcase }}"
  complexity: 330
  error_mode: lax
  errors:
    parse_error:
      - "unexpected"
      - "filter"
  hint: |
    Double pipes (||) are not valid Liquid syntax. The lexer/parser should
    detect malformed filter chains. While '|' separates filters, '||' is
    invalid. Syntax errors should be detected during parsing.

- name: "very_long_string_filter"
  template: "{{ long_string | size }}"
  environment: { long_string: instantiate:LongString: { length: 100000 } }
  expected: "100000"
  complexity: 290
  error_mode: lax
  hint: |
    Filters should handle very long strings without crashing. The size filter
    should work on strings of any length. While there may be practical limits
    (memory, timeout), the filter logic itself should not have hardcoded
    length restrictions. This tests that filters properly handle edge cases
    in input size. The data field here uses Ruby syntax to generate a long
    string; adapt based on your spec processing system.

- name: "deeply_nested_property_access_lax"
  template: "{{ a.b.c.d.e.f.g.h.i.j }}"
  environment: { a: { b: { c: { d: { e: { f: { g: { h: { i: {} } } } } } } } } }
  expected: ""
  complexity: 310
  error_mode: lax
  hint: |
    Deep property access chains should work up to the point where a property
    doesn't exist. Here the chain reaches 'i' (an empty object), then accessing
    .j returns nil. The system should handle arbitrary nesting depth without
    stack overflow or recursion limits. Each property access should be
    nil-safe, returning nil as soon as any intermediate value is nil or
    doesn't have the requested property.

- name: "filter_on_nil_value_lax"
  template: "{{ missing | upcase }}"
  environment: {}
  expected: ""
  complexity: 225
  error_mode: lax
  hint: |
    Filters applied to nil/undefined variables should handle nil input gracefully.
    The upcase filter receives nil as input (since 'missing' is undefined).
    Filters should check for nil input and either return nil or handle it
    appropriately. Most filters return nil when given nil input. This prevents
    errors when applying filters in filter chains where earlier values might
    be nil.

- name: "negative_array_index_out_of_bounds_lax"
  template: "{{ items[-10] }}"
  environment: { items: ["a", "b", "c"] }
  expected: ""
  complexity: 260
  error_mode: lax
  hint: |
    Negative array indices that go beyond the array bounds should return nil.
    The array has 3 elements, so [-10] would be index -7 when adjusted,
    which is out of bounds. Array access should validate indices (both positive
    and negative) and return nil for out-of-bounds access in lax mode. Never
    throw exceptions for array index errors in lax mode.

- name: "undefined_variable_in_filter_argument_lax"
  template: "{{ 'hello' | slice: missing_index }}"
  environment: {}
  expected: "Liquid error (line 1): invalid integer"
  complexity: 275
  error_mode: lax
  render_errors: true
  hint: |
    When a filter argument references an undefined variable, the filter receives
    nil as the argument. The slice filter gets nil instead of a number. In
    Liquid, this produces an error message about invalid integer type rather
    than silently failing. This helps identify when filter arguments are missing
    or incorrectly typed while still continuing template execution.

- name: "error_in_nested_block_lax"
  template: "{% for item in items %}{{ item.missing }}{% endfor %}"
  environment: { items: [{ name: "a" }, { name: "b" }] }
  expected: ""
  complexity: 285
  error_mode: lax
  hint: |
    Errors inside loops or other block structures should be handled per-iteration
    in lax mode. Each iteration tries to access .missing on an item, which
    doesn't exist. Each access returns nil (empty string). The loop continues
    normally. Errors inside blocks should not break the block execution in
    lax mode. Each iteration is independent in terms of error handling.

- name: "strict_mode_with_nil_safe_access"
  template: "{{ user.profile.name | default: 'Anonymous' }}"
  environment: { user: { profile: null } }
  expected: "Anonymous"
  complexity: 295
  error_mode: strict
  hint: |
    Even in strict mode, nil-safe property access should work when the value
    is explicitly nil (not undefined). Here 'profile' exists but is nil, so
    .name returns nil, which is passed to the default filter. Strict mode
    errors on undefined variables, but explicit nil values should be handled
    gracefully. The default filter provides a fallback for nil values.

- name: "empty_filter_chain_lax"
  template: "{{ 'hello' | }}"
  complexity: 340
  error_mode: lax
  errors:
    parse_error:
      - "filter"
  hint: |
    A filter pipe with no filter name is a syntax error. Even in lax mode,
    this cannot be parsed correctly. The parser should detect the incomplete
    filter chain syntax - a '|' must be followed by a filter name.

- name: "recursive_variable_reference"
  template: "{{ a }}"
  environment: { a: "{{ b }}", b: "{{ a }}" }
  expected: "{{ b }}"
  complexity: 350
  error_mode: lax
  hint: |
    Variable values should not be recursively parsed as Liquid templates.
    When 'a' contains "{{ b }}", it should be output literally, not parsed
    as a nested template. Liquid does not support recursive template expansion
    in variable values. The string "{{ b }}" is just text data. This prevents
    infinite recursion and keeps the parser simple. Only the original template
    is parsed, not variable contents.
