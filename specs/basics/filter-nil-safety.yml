# Liquid Filter Nil Safety Specs
# Progressive difficulty: 40-150
# Focus: How filters handle nil input, nil arguments, nil in pipelines, and nil-safety patterns

- name: "upcase_on_nil"
  template: "{{ missing | upcase }}"
  environment: {}
  expected: ""
  complexity: 40
  hint: |
    String filters on nil should return empty string. When the input
    is nil (from undefined variable 'missing'), the upcase filter
    should gracefully return "" instead of erroring. Check if input
    is nil before applying string operations. This is Liquid's
    fundamental nil-safety guarantee for string filters.

- name: "downcase_on_nil"
  template: "{{ missing | downcase }}"
  environment: {}
  expected: ""
  complexity: 40
  hint: |
    The downcase filter should handle nil input by returning empty string.
    When input is nil, don't attempt to call downcase operations on it.
    Instead, detect nil early and return "". All string transformation
    filters follow this pattern for nil-safety.

- name: "strip_on_nil"
  template: "{{ missing | strip }}"
  environment: {}
  expected: ""
  complexity: 45
  hint: |
    The strip filter removes whitespace from strings, but on nil input
    should return empty string. Check if input is nil before attempting
    to trim whitespace. Nil has no whitespace to strip, so the sensible
    result is "". This prevents errors when variables are undefined.

- name: "capitalize_on_nil"
  template: "{{ missing | capitalize }}"
  environment: {}
  expected: ""
  complexity: 45
  hint: |
    The capitalize filter uppercases the first character of a string.
    When input is nil, return empty string instead of attempting to
    access the first character of nothing. Nil-safe string filters
    always check for nil before string manipulation.

- name: "first_on_nil"
  template: "{{ missing | first }}"
  environment: {}
  expected: ""
  complexity: 50
  hint: |
    Array filters on nil should return empty string. The first filter
    gets the first element of an array. When input is nil (not an array),
    return "". Check if input is nil or not an array before attempting
    to access elements. Nil has no first element.

- name: "last_on_nil"
  template: "{{ missing | last }}"
  environment: {}
  expected: ""
  complexity: 50
  hint: |
    The last filter gets the last element of an array. When input is
    nil, return empty string. Nil is not a collection with a last element,
    so gracefully return "". This prevents errors when iterating or
    accessing undefined array variables.

- name: "size_on_nil"
  template: "{{ missing | size }}"
  environment: {}
  expected: "0"
  complexity: 55
  hint: |
    The size filter returns the length of a collection. When input is
    nil, return 0 (as a number, which becomes "0" string in output).
    Nil has no elements, so its size is 0. This is different from
    string filters that return empty string - size returns a numeric 0.

- name: "sort_on_nil"
  template: "{{ missing | sort }}"
  environment: {}
  expected: ""
  complexity: 60
  hint: |
    The sort filter arranges array elements in order. When input is
    nil, return empty string. Nil is not an array to sort, so return "".
    Check for nil input before attempting to sort elements. This prevents
    errors when sorting undefined variables.

- name: "reverse_on_nil"
  template: "{{ missing | reverse }}"
  environment: {}
  expected: ""
  complexity: 60
  hint: |
    The reverse filter reverses array order. When input is nil, return
    empty string. Nil has no elements to reverse, so gracefully return "".
    Array manipulation filters should all check for nil input and return
    empty string to maintain nil-safety.

- name: "join_on_nil"
  template: "{{ missing | join: ',' }}"
  environment: {}
  expected: ""
  complexity: 65
  hint: |
    The join filter combines array elements with a separator. When input
    is nil, return empty string regardless of separator. Nil is not an
    array with elements to join, so return "". The separator argument
    is irrelevant when there's nothing to join.

- name: "plus_on_nil"
  template: "{{ missing | plus: 5 }}"
  environment: {}
  expected: "5"
  complexity: 70
  hint: |
    Math filters treat nil as 0. When input is nil, coerce it to 0
    before performing arithmetic. Nil + 5 = 0 + 5 = 5. This allows
    graceful math operations on undefined variables without errors.
    Check for nil and convert to 0 before addition.

- name: "minus_on_nil"
  template: "{{ missing | minus: 3 }}"
  environment: {}
  expected: "-3"
  complexity: 70
  hint: |
    The minus filter treats nil input as 0. Compute nil - 3 = 0 - 3 = -3.
    Coerce nil to 0 before subtraction. This enables math operations
    to work even when variables are undefined, treating absence as
    numeric zero.

- name: "times_on_nil"
  template: "{{ missing | times: 4 }}"
  environment: {}
  expected: "0"
  complexity: 75
  hint: |
    The times filter treats nil as 0. Compute nil * 4 = 0 * 4 = 0.
    Any number multiplied by 0 (nil) is 0. Coerce nil input to 0
    before multiplication. This maintains nil-safety in multiplication
    operations.

- name: "divided_by_on_nil"
  template: "{{ missing | divided_by: 2 }}"
  environment: {}
  expected: "0"
  complexity: 75
  hint: |
    The divided_by filter treats nil as 0. Compute nil / 2 = 0 / 2 = 0.
    Zero divided by any non-zero number is 0. Coerce nil input to 0
    before division. This prevents division errors on undefined variables.

- name: "date_filter_on_nil"
  template: "{{ missing | date: '%Y-%m-%d' }}"
  environment: {}
  expected: ""
  complexity: 80
  hint: |
    The date filter formats dates. When input is nil, return empty string.
    Nil is not a valid date to format, so gracefully return "". Check
    if input is nil before attempting date formatting operations. The
    format string is irrelevant when there's no date to format.

- name: "default_filter_nil_escape"
  template: "{{ missing | default: 'N/A' }}"
  environment: {}
  expected: "N/A"
  complexity: 85
  hint: |
    The default filter is the primary nil-safety escape hatch. When
    input is nil (or empty), return the default value instead. This
    allows you to provide fallbacks for undefined variables. Check
    if input is nil/false/empty, and if so, return the argument.

- name: "chained_filters_intermediate_nil"
  template: "{{ user.name | upcase | append: '!' }}"
  environment: { user: {} }
  expected: "!"
  complexity: 90
  hint: |
    When chaining filters, intermediate nil values should propagate safely.
    user.name is nil (missing property), upcase on nil returns "",
    then append '!' to "" gives "!". Each filter in the chain handles
    nil safely, passing empty string to the next filter.

- name: "map_with_nil_property"
  template: "{{ users | map: 'email' | first }}"
  environment: { users: [{name: 'Alice'}, {name: 'Bob'}] }
  expected: ""
  complexity: 95
  hint: |
    The map filter extracts a property from each object. When objects
    don't have the property, map produces nil values. Accessing 'email'
    on objects without that property yields nil. The first filter on
    an array of nils returns the first element (nil), which outputs
    as empty string.

- name: "compact_filter_removes_nils"
  template: "{{ items | compact | join: ',' }}"
  environment: { items: ['a', null, 'b', null, 'c'] }
  expected: "a,b,c"
  complexity: 100
  hint: |
    The compact filter removes nil values from arrays. Iterate through
    the input array and filter out any nil elements. From ['a', nil, 'b',
    nil, 'c'], remove nils to get ['a', 'b', 'c'], then join with ','
    to get "a,b,c". This is useful for cleaning data before processing.

- name: "append_with_nil_argument"
  template: "{{ 'hello' | append: missing }}"
  environment: {}
  expected: "hello"
  complexity: 105
  hint: |
    When a filter argument is nil, treat it appropriately. The append
    filter concatenates strings. When the argument is nil (undefined
    variable 'missing'), convert nil to empty string, then append ""
    to 'hello' to get "hello". Nil arguments should be coerced to empty
    strings in string operations.

- name: "split_then_compact"
  template: "{{ text | split: ',' | compact | size }}"
  environment: { text: "a,,b,c" }
  expected: "4"
  complexity: 110
  hint: |
    Split 'a,,b,c' by ',' gives ['a', '', 'b', 'c']. Split creates
    empty strings for consecutive delimiters, not nils. Compact only
    removes nil values, not empty strings. So the array stays
    ['a', '', 'b', 'c'], and size is 4. This tests the distinction
    between nil and empty string - compact doesn't affect empty strings.

- name: "where_filter_with_nil_values"
  template: "{{ products | where: 'available' | size }}"
  environment: { products: [{available: true}, {available: null}, {available: true}] }
  expected: "2"
  complexity: 115
  hint: |
    The where filter selects objects where a property is truthy. Check
    each object's 'available' property. True is truthy (include), nil
    is falsy (exclude), true is truthy (include). Result is 2 objects.
    Nil properties fail the truthiness test, so objects with nil values
    are filtered out.

- name: "default_with_chained_filters"
  template: "{{ missing | upcase | default: 'NONE' }}"
  environment: {}
  expected: "NONE"
  complexity: 120
  hint: |
    Chain default after other filters to provide fallback. missing is nil,
    upcase on nil returns "", then default checks if "" is empty (it is),
    so return the default 'NONE'. This pattern safely handles undefined
    variables by applying transformations first, then providing fallback.

- name: "replace_with_nil_in_string"
  template: "{{ 'hello' | replace: 'l', missing }}"
  environment: {}
  expected: "heo"
  complexity: 125
  hint: |
    The replace filter substitutes text. When the replacement argument
    is nil, treat it as empty string. Replace 'l' with "" (nil coerced),
    so 'hello' becomes 'heo'. Nil in replacement context means "replace
    with nothing" (deletion). Coerce nil arguments to empty strings.

- name: "slice_on_nil"
  template: "{{ missing | slice: 0, 3 }}"
  environment: {}
  expected: ""
  complexity: 130
  hint: |
    The slice filter extracts a substring or subarray. When input is
    nil, return empty string. Nil has no characters or elements to
    slice, so gracefully return "". Check for nil input before attempting
    to extract substrings. Slice arguments are irrelevant for nil input.

- name: "uniq_with_nils"
  template: "{{ items | uniq | size }}"
  environment: { items: [1, null, 2, null, 3] }
  expected: "4"
  complexity: 135
  hint: |
    The uniq filter removes duplicate values. Multiple nils count as
    duplicates. From [1, nil, 2, nil, 3], uniq produces [1, nil, 2, 3]
    (one nil kept, one removed). Size is 4. Treat nil as a value that
    can be duplicated; keep only one instance of nil when deduplicating.

- name: "complex_nil_chain"
  template: "{{ users | map: 'profile' | map: 'bio' | compact | first | upcase | default: 'NO BIO' }}"
  environment: { users: [{profile: {}}, {profile: {bio: 'hello'}}] }
  expected: "HELLO"
  complexity: 145
  hint: |
    Complex chain with multiple nil-handling steps. Map 'profile' then
    map 'bio' gives [nil, 'hello']. Compact removes nils to get ['hello'].
    First gets 'hello'. Upcase gives 'HELLO'. Default not triggered because
    'HELLO' is not empty. This tests that compact successfully removes
    nils from mapped results before further processing. Note: liquid-ruby
    requires separate map calls for nested properties.

- name: "nil_in_comparison_filters"
  template: "{{ missing | at_least: 10 }}"
  environment: {}
  expected: "10"
  complexity: 140
  hint: |
    The at_least filter returns the maximum of input and argument.
    When input is nil, coerce to 0. Then at_least(0, 10) returns 10.
    Math comparison filters treat nil as 0, just like arithmetic filters.
    This maintains consistent nil-handling across all numeric filters.

- name: "truncate_on_nil"
  template: "{{ missing | truncate: 10 }}"
  environment: {}
  expected: ""
  complexity: 130
  hint: |
    The truncate filter shortens strings. When input is nil, return
    empty string. Nil has no characters to truncate, so return "".
    Check for nil input before attempting to measure length or extract
    substrings. String manipulation filters universally return empty
    string for nil input.

- name: "url_encode_on_nil"
  template: "{{ missing | url_encode }}"
  environment: {}
  expected: ""
  complexity: 135
  hint: |
    The url_encode filter escapes strings for URLs. When input is nil,
    return empty string. Nil has no characters to encode, so return "".
    String transformation filters, including encoding filters, handle
    nil by returning empty string to maintain nil-safety.

- name: "abs_on_nil"
  template: "{{ missing | abs }}"
  environment: {}
  expected: "0"
  complexity: 140
  hint: |
    The abs filter computes absolute value. When input is nil, treat
    as 0. abs(nil) = abs(0) = 0. Math filters consistently treat nil
    as 0, allowing graceful numeric operations on undefined variables.
    This prevents errors and provides sensible default behavior.

- name: "strip_html_on_nil"
  template: "{{ missing | strip_html }}"
  environment: {}
  expected: ""
  complexity: 145
  hint: |
    The strip_html filter removes HTML tags from strings. When input
    is nil, return empty string. Nil has no HTML to strip, so return "".
    All string processing filters (transformation, extraction, stripping)
    handle nil input by returning empty string for consistency.

- name: "map_compact_size_pattern"
  template: "{{ users | map: 'age' | compact | size }}"
  environment: { users: [{name: 'Alice', age: 30}, {name: 'Bob'}] }
  expected: "1"
  complexity: 150
  hint: |
    Common pattern for counting objects with a property. Map 'age'
    produces [30, nil] (Bob has no age). Compact removes nils to get [30].
    Size is 1. This pattern counts how many objects have the specified
    property. Map+compact+size is idiomatic for counting defined values.
